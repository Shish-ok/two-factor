# Микросервис двухфаторной авторизации

## Локальный запуск

Для локального запуска склонируйте к себе репозиторий и в папке с ним выполните следующую команду:

```bash
docker-compose up -d
```

После запуска, чтобы вручную протестировать api откройте ссылку http://localhost:8080/swagger/index.html

## API эндпоинты

#### Отправка номера

Генерирует uid запроса и код для авторизации

```http
POST http://localhost:8080/api/v1/send
```
Request (body JSON):
```json
{
  "number": "+79109994994"
}
```
Response (JSON):
```json
{
  "requestId": "f2441c3c-5970-43ba-a952-ed18a00d5fa6",
  "code": 1234
}
```
#### Верефикация кода двухфакторной авторизации
Проверяет код авторизации по uid запроса и возвращает дату в UnixTime, если всё хорошо
```http
POST http://localhost:8080/api/v1/verify
```
Request (body JSON):
```json
{
  "requestId": "f2441c3c-5970-43ba-a952-ed18a00d5fa6",
  "code": 1234
}
```
Response (JSON):
```json
{
  "verifiedAt": 1679391224
}
```

Также можете ознакомиться с документацией swagger в файле [swagger.yaml](https://github.com/Shish-ok/two-factor/blob/master/docs/swagger.yaml)

## Проблемы и решения

#### Хранение информации в памяти сервиса (восстановление при перезапуске)
Для хранения информации используется redis. К сожалению, Go не имеет библиотек для работы с миграцией данных из снимков dump.rdb, поэтому в рамках docker контейнера 
был написан отдельный сервисный слой для резервного копирования при остановке контейнера и восстановления данных при повторном запуске. Не самое оптимальное решение, но данные сохраняются

В случае развёртывания на хосте я бы использовал ci\cd и раскатывал бы снимки в отдельную директорию хоста.

#### Архитектурный подход
Для локального запуска было принято решение поднимать api и redis в одном docker-compose, однако при деплое на хост я бы разворачивал отдельно redis и api, подключив их к общей сети docker.
Но лучше всего, конечно, использовать kubernetes
